# エンタープライズアプリケーションアーキテクチャパターン

## レイヤ化

### レイヤ化とは
* ソフトウェア設計者が複雑なソフトウェアのシステムを分割するために使用する一般的な技法である

#### レイヤを分割するメリット
* 他のレイヤを知らなくても、１つのレイヤを全体として考えることができる
* 同じ基本サービスの代替実装でレイヤを置き換えることができる
* レイヤ間の依存を最小限にすることができる
* レイヤを構築すれば多くの高水準サービスがそのレイヤを使用することができる

#### レイヤを分割することでのデメリット
* レイヤは一部の物事をカプセル化してしまう。その結果、連鎖的な変更が起こる場合がある。
* パフォーマンスを損ねる可能性がある

### レイヤ化の発展
* レイヤの概念は90年代のクライアント/サーバーシステムの発展とともに明確になった。
* クライアント/サーバーのシステムは2レイヤのシステムだった(クライアントはUIとアプリケーションコード,サーバーはリレーショナルデータベース)
* アプリケーションがリレーショナルデータベースの更新だけを行う場合、クライアント/サーバーシステムは適切に動作した。問題は、ビジネスルール、妥当性、計算などのドメインロジックを伴った時である。
* この問題の解決方法として、ドメインロジックをストアドプロシージャとしてデータベースに格納することがあげられる。しかし、ストアドプロシージャには弱点があり、その構造化のメカニズムには限界があるため、再び厄介なコードの作成につながってしまう。また、ストアドプロシージャは各データベースベンダの固有のものであるため、ベンダの変更について選択肢がなくなってしまう。

###　オブジェクト指向
* クライアントサーバーが人気を博したこと、オブジェクト指向も人気を集めていた。
* オブジェクト指向のコミュニティーは「３レイヤのシステムに移行する」ことでドメインロジックに関する問題を解決した。
* だが、オブジェクト指向は主流にはならなかった。多くのシステムはまだあまりにシンプルなものだった。(少なくとも開発時には.....)
* Javaの登場によってオブジェクト指向が堂々と主流を占めるようになった。

## 3つの主なレイヤ

### プレゼンテーションレイヤ
* サービスの提供、情報の表示
* ユーザーとソフトウェアの相互作用を行う。このロジックは、コマンドラインや、テキストベースのメニューシステムと同じくらいシンプルな場合もあるが、現在はリッチになりつつある

### ドメインレイヤ
* システムそのものであるロジック
* ビジネスロジックとも呼ばれる。
* 現在作業中のドメインに対して、アプリケーションが行うべき作業である。

### データソースレイヤ
* データベース、メッセージングシステム、トランザクションモニタ、その他パッケージとの通信
* 他のシステムとの通信を行い、アプリケーションのためのタスクを実行する。
* エンタープライズアプリケーションの多くでは、データソースロジックはデータベースであることがおおい。


レイヤの配置において、プレゼンテーションレイヤからデータストアに直接アクセスしがち。

1つのアプリケーションにはこの3つの分野ごとに複数のパッケージが存在することが多い。リッチクライアントのインターフェースを利用するエンドユーザーだけでなく、コマンドラインを利用するユーザーもいることがある。

* バッチシステムなどの場合、ユーザーはクライアントシステムとなる
* この点でプレゼンテーションレイヤとデータソースレイヤには多くの類似点があるように見える。(どちらも外部との接続に関するレイヤであるため)
* これはヘキサゴナルアーキテクチャパターンの背後にあるロジックである。ヘキサゴナルアーキテクチャとは、外部システムへのインターフェースで囲まれた核としてのシステムを視覚化したものである。
* ヘキサゴナルアーキテクチャでは、外部にあるものは基本的に全て外側のインターフェースであり、したがってこれは対照的なviewであり、非対称のレイヤ化のスキーまではない。
* プレゼンテーションは、他者に対してのシステムが提供するサービスの外部インターフェースである。この場合、提供する相手が複雑な人間であるか、単純なリモートシステムであるかは問わない。

### レイヤの分割について
* これら３つのレイヤをどのように分けるかは、アプリケーションがどれだけ複雑であるかによって変わってくる。
* 状況に応じて、最も適切な分割の仕方を選択すること、ただし最低限のサブルーティンレベルでの分割は行なった方が良い

### 依存性
* 分割だけでなく、依存性についてのも明確なルールがある。ドメインとデータソースはプレゼンテーションに依存してはいけない。言い換えると、ドメインのコードやデータソースコードからプレゼンテーションないのサブルーティンを呼び出してはいけない。
* ドメインとデータソースの関係は複雑でデータソースのアーキテクチャパターンによって異なる。


### ドメインロジック
* ドメインロジックの扱いで最も難しいのは、人々が思っているように何がドメインロジックで、なにがそれ以外であるか見極めること
* 例として、webアプリケーションにコマンドラインツールを追加する時のように、全く異なるレイヤをアプリケーションに追加することを考える
* この追加を行うときに、機能を複製する必要があれば、それはドメインロジックがプレゼンテーションの中にはみ出しているということ
* 同様にリレーショナルデータベースをXMLに置き換えることなどを考えてみるのも良い


### レイヤの実行場所の選択
* データソースは常にサーバーでのみだけ実行される
* プレゼンテーションを実行する場所は、UIの種類によって決まることが多い。リッチクライアントの実行はクライアントで実行するのと同義
* ドメインロジックは全てサーバーで実行することも、全てクライアントで実行することもできる。また、分割することもできる。
* だが、サーバーで実行することが保守性を容易にするための最善の方法である。

## ドメインロジックの構築

### ドメインロジックの構築パターン
1. トランザクションスクリプト
2. ドメインモデル
3. テーブルモジュール

#### トランザクションスクリプト
* 最もシンプルな方法
* 本質的にはプレゼンテーションからの入力を取得するための手続き
* 妥当性の確認と計算によって入力を処理し、データベースにデータを格納し、他のシステムの操作を呼び出す
* ユーザーが望んでいるアクションのための手続きを1つずつ構築するのが基本
* アクション用のスクリプト、ビジネストランザクションと考えることが多い

##### 長所
* 開発者なら大半が理解できるシンプルな手続きモデルである
* 行データゲートウェイやテーブルデータゲートウェイを使用するシンプルなデータレイヤと適切に連携する
* トランザクションの境界を設定する方法がはっきりしている。トランザクションを開始して、それをクローズする。

##### 短所
* ドメインロジックが複雑になってくると、短所が見えてくる
* トランザクションが同じ動きを行い必要があるので、コードが重複してくる
* その重複の一部はサブルーティン化などで抜き出すことができるが、その多くは削除すのも発見するのも難しい。
* もちろん複雑なロジックはオブジェクトが関わるところであり、オブジェクト指向ではこの問題をドメインモデルとして解決する。

#### ドメインモデル
* 少なくとも概要レベルで、主にドメイン内の名詞について体系化したモデルを構築する
* 例えば、賃貸システムであれば、賃貸借契約、資産などのクラスがあると考えられる
* トランザクションスクリプトではなく、ドメインモデルを利用することは、オブジェクト指向のユーザーがいうことろのパラダイムシフト
* 1つのルーティンがユーザーアクションのロジックの全てを持つのではなく、各オブジェクトが自身に関係ある部分のロジックを担当する
* ドメインモデルがリッチになるにつれて、リレーショナルデータベースへのマッピングが複雑になる

#### テーブルモジュール
